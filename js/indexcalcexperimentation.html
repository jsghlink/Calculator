<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Experimentation code</title>
    <!-- <link rel="stylesheet" href="css/stylescalctable.css"> -->
    <!-- <script src="js/scriptcalctable.js" defer></script> -->
</head>
<body>
    <div id="boyoex">
        Greatness
    </div>
    <script>
//          number.push(document.getElementById("input").value);

//          var items = [];

// function guardarNumeros(){

//  boxvalue = document.getElementById('box').value;
//  items.push(boxvalue);  
//  console.log(items);

// }

        // let boyo = []; 
        // boyo = document.getElementById("boyoex");
        // console.log(boyo[4].innerText);

        // let a = prompt("Enter a number");
        // let b = prompt("Enter another number");
        // function sum (x,y) {
        //     return 'x' + 'y';
        // }
        // alert(`Result: ${sum(a,b)}`);
        // console.log("Result: sum(x,y)");
        let string = 'harry_and_james';

console.log("The given string is:", string)

let subBefore = string.split('_')[0];

let subBefore1 = string.split('_')[1];

console.log("The substrings before the specific character are:", subBefore + subBefore1);
//  function checkDec(el){
//     var ex = /^[0-9]+\.?[0-9]*$/;
//      if(ex.test(el.value)==false){
//          alert('Incorrect Number');
//      }
// }



// <!DOCTYPE html>
// <html>
// <body>

// <h1>JavaScript Strings</h1>
// <h2>The substr() Method</h2>

// <p>substr() extracts a part of a string:</p>

// <p id="demo"></p>

// <script>
// let text = "Hello world!";
// let eqregexdefformat = /[a-zA-Z]{5}\s[a-zA-Z]{5}!/g;
// if (eqregexdefformat.test(text) === true) {
// let indexofop = text.indexOf('o');
// let result = text.substr(indexofop, 1);

// // document.getElementById("demo").innerHTML = result;
// switch (result) {
    
//             case 'o': document.getElementById("demo").innerHTML = result; //additionPerform(numonestore, numtwostore);
//             default : document.getElementById("demo").innerHTML = "Check complete";
//         } 
// }




















let checkingval, stringassigntemp, indexofop, numonestore, numtwostore, opstore, opconsecutiveaddop = "+", opconsecutivemulop = "*", opconsecutivedivop = "/", opconsecutivesubop = "-";
// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx




// num1store, opstore, num2store
// if (inputhai.value === "123") {
//     inputhai.value = "Check complete"
// } did not work; conclusion drawn to check conditions on event
let eqregexdefformat = /\d+\+\d+/g; // default format
let eqregexnumonly = /\d+/g;        // 5, (then =)
let eqregexnumandoponly = /\d+\+/g; // 5+, (then =)
let opregexdefformat = /\d+\+\d+/g; // default format used again while clicking '+' operator
let opregexnumzeroatstart = /0\+/g; // matches '0+' at the start when op is clicked
let opregexnumandoponly = /\d+\+/g; // i) 0+ ii) 5+ 
let ccregexnoconsecutive = /\+{2,}/g; ///\++?/g;// // matches 2 or more '+' operators // default was {2,}, can negation be used (if ^, includes === true, if not 0 or 1)
let ccregexnoconsecutive2 = /^\+?/g;
let ccregexnoconsecutiveeq = /={2,}/g; // matches 2 or more '=' operators

let eqregexopandnumonly = /\+\d+/g;  // +5, (then =)  // also been used for add op
let eqregexoponly = /\+/g;           // +,  (then =)

let opregexdefformatmulop = /\d+\*\d+/g;
// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx





// behaviour of buttons on click
let valueone = document.getElementById("numbutt1");
let valuetwo = document.getElementById("numbutt2");
let valuethree = document.getElementById("numbutt3"); // marker
let valuefour = document.getElementById("numbutt4");
let valuefive = document.getElementById("numbutt5");
let valuesix = document.getElementById("numbutt6");
let valueseven = document.getElementById("numbutt7");
let valueeight = document.getElementById("numbutt8");
let valuenine = document.getElementById("numbutt9");
let valuezero = document.getElementById("numbutt0");
let additionop = document.getElementById("addop");
let multiplicationop = document.getElementById("mulop");

let deleteop = document.getElementById("delop");
let clearop = document.getElementById("clrop");
// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx






// input field
//let inputhai = []; // values stored in an array
let inputhai = document.getElementById("dispbutt"); // array input lena hai kya?
// Found out this eventually returns a string. let inputhai = []; redundant hai, serves no purpose - check push later

// event listeners for number buttons. '3' has been kept for experiments
valueone.addEventListener("click", myFunco);
function myFunco() {
    inputhai.value += valueone.value;
}

valuetwo.addEventListener("click", myFunco2);
function myFunco2() {
    inputhai.value += valuetwo.innerHTML;  // observation recorded on inputhai.value vs inputhai.text etc. - Find out more
}

valuethree.addEventListener("click", myFunco3);
function myFunco3() {
    // e.preventDefault(); this works! 
    inputhai.value += valuethree.innerText; // take note of this development
}

valuefour.addEventListener("click", function (e) {
    // Don't redirect user to the link
    inputhai.value += valuefour.innerText;
    // if (inputhai.value = 12) {
    // e.preventDefault();
    // } check this
})
// valuefour.addEventListener("click", myFunco4);
// function myFunco4() {
//     inputhai.value += valuefour.innerText;
  
// }
valuefive.addEventListener("click", myFunco5);
function myFunco5() {
    inputhai.value += valuefive.innerText;
}
valuesix.addEventListener("click", myFunco6);
function myFunco6() {
    inputhai.value += valuesix.innerText;
}
valueseven.addEventListener("click", myFunco7);
function myFunco7() {
    inputhai.value += valueseven.innerText;
}
valueeight.addEventListener("click", myFunco8);
function myFunco8() {
    inputhai.value += valueeight.innerText;
}
valuenine.addEventListener("click", myFunco9);
function myFunco9() {
    inputhai.value += valuenine.innerText;
}
valuezero.addEventListener("click", myFunco0);
function myFunco0() {
    inputhai.value += valuezero.innerText;
}
// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx






additionop.addEventListener("click", myFuncoAdditionOp);
function myFuncoAdditionOp() {
    // test starting and ending condition
    // if (inputhai.value === "123")
    // {
    //     return inputhai.value = "10000"; // take care to add "" in strings, used check complete in string
        
    // }
    if (opregexdefformat.test(inputhai.value) === true ) {
        stringassigntemp = inputhai.value;
        if (stringassigntemp.includes('+') === true) {
        indexofop = stringassigntemp.indexOf('+');
        numonestore = stringassigntemp.slice(0,stringassigntemp.indexOf('+')); // or indexop
        numtwostore = stringassigntemp.slice(stringassigntemp.indexOf('+') + 1); // or indexop
        opstore = stringassigntemp.substr(indexofop,1); // can also use slice
    // } // contemplate this bracket's positioning
        if (opstore = '+') {
            additionPerform(numonestore, numtwostore);
        } //|| if () || if () || if ()
        // switch (opstore) {
    
        //     case '+': additionPerform(numonestore, numtwostore);
        //     default : inputhai.value = "Check complete";
        // } 

    }
} else if (opregexnumandoponly.test(inputhai.value) === true ) {
    // look at eqregexnumandoponly
    stringassigntemp = inputhai.value;
    if (stringassigntemp.includes('+') === true) {
    indexofop = stringassigntemp.indexOf('+');
    numonestore = stringassigntemp.slice(0,stringassigntemp.indexOf('+')); 
    numtwostore = "0";
    opstore = stringassigntemp.substr(indexofop,1); // can also use slice
// } // contemplate this bracket's positioning
    if (opstore = '+') {
        additionPerform(numonestore, numtwostore);
    } //|| if () || if () || if ()
}
} else if (eqregexopandnumonly.test(inputhai.value) === true ) { // there should be a separate regex for this - assign and update comment
    stringassigntemp = inputhai.value;
    if (stringassigntemp.includes('+') === true) {
        indexofop = stringassigntemp.indexOf('+');
        numonestore = "0";
        numtwostore = stringassigntemp.slice(stringassigntemp.indexOf('+') + 1);
        opstore = stringassigntemp.substr(indexofop,1);
        if (opstore = '+') {
            additionPerform(numonestore, numtwostore);
        }
}
} else if (inputhai.value.indexOf(opconsecutiveaddop) > 0 ) {
    return false;
}

else if (inputhai.value.indexOf(opconsecutiveaddop) < 0) {
    return inputhai.value += "+";
}

// * else if (ccregexnoconsecutive2.test(inputhai.value) === true ) {
//     stringassigntemp = inputhai.value;
//     noConsecutiveAddOp();
// }
   // * else inputhai.value += additionop.innerText; // does else come into play here
   // check what happens if the else condition is removed - 'tis necessary, 
   // else inputhai.value += additionop.innerText; is/was here
}
// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx





multiplicationop.addEventListener("click", myFuncoMultiplicationOp);
function myFuncoMultiplicationOp() {
    
    if (opregexdefformatmulop.test(inputhai.value) === true ) {
        stringassigntemp = inputhai.value;

        if (stringassigntemp.includes('*') === true) {
        indexofop = stringassigntemp.indexOf('*');
        numonestore = stringassigntemp.slice(0,stringassigntemp.indexOf('*')); 
        numtwostore = stringassigntemp.slice(stringassigntemp.indexOf('*') + 1);
        opstore = stringassigntemp.substr(indexofop,1); // can also use slice
    // } // contemplate this bracket's positioning
        if (opstore = '*') {
            multiplicationPerform(numonestore, numtwostore);
        } //|| if () || if () || if ()
        // switch (opstore) {
    
        //     case '+': additionPerform(numonestore, numtwostore);
        //     default : inputhai.value = "Check complete";
        // } 

    }
} else if (opregexnumandoponly.test(inputhai.value) === true ) {
    // look at eqregexnumandoponly
    stringassigntemp = inputhai.value;
    if (stringassigntemp.includes('*') === true) {
    indexofop = stringassigntemp.indexOf('*');
    numonestore = stringassigntemp.slice(0,stringassigntemp.indexOf('*')); 
    numtwostore = "0";
    opstore = stringassigntemp.substr(indexofop,1); // can also use slice
// } // contemplate this bracket's positioning
    if (opstore = '*') {
        multiplicationPerform(numonestore, numtwostore);
    } //|| if () || if () || if ()
}
} else if (eqregexopandnumonly.test(inputhai.value) === true ) {
    stringassigntemp = inputhai.value;
    if (stringassigntemp.includes('*') === true) {
        indexofop = stringassigntemp.indexOf('*');
        numonestore = "0";
        numtwostore = stringassigntemp.slice(stringassigntemp.indexOf('*') + 1);
        opstore = stringassigntemp.substr(indexofop,1);
        if (opstore = '*') {
            multiplicationPerform(numonestore, numtwostore);
        }
}
} else if (inputhai.value.indexOf(opconsecutivemulop) > 0 ) {
    return false;
}

else if (inputhai.value.indexOf(opconsecutivemulop) < 0) {
    return inputhai.value += "*";
}
}
// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx





equalop.addEventListener("click", myFuncoEqualOp);
function myFuncoEqualOp() {
    // e.preventDefault(); this works! 
    // inputhai.value += equalop.innerText; // take note of this development
    if (eqregexdefformat.test(inputhai.value) === true ) {
        stringassigntemp = inputhai.value;
        if (stringassigntemp.includes('+') === true) {
        indexofop = stringassigntemp.indexOf('+');
        numonestore = stringassigntemp.slice(0,stringassigntemp.indexOf('+')); // or indexop
        numtwostore = stringassigntemp.slice(stringassigntemp.indexOf('+') + 1); // or indexop
        opstore = stringassigntemp.substr(indexofop,1); // can also use slice
    // } // contemplate this bracket's positioning
        if (opstore = '+') {
            additionPerform(numonestore, numtwostore);
        } //|| if () || if () || if ()
        // switch (opstore) {
    
        //     case '+': additionPerform(numonestore, numtwostore);
        //     default : inputhai.value = "Check complete";
        // } 

    }   // start else if loops for operators from here
} 
else if (eqregexnumonly.test(inputhai.value) === true ) {
    stringassigntemp = inputhai.value;
    numOnlyEqualOp(stringassigntemp); // try numOnlyEqualOp(inputhai.value)
}
else if (eqregexnumandoponly.test(inputhai.value) === true ) {
    stringassigntemp = inputhai.value;
    if (stringassigntemp.includes('+') === true) {
    indexofop = stringassigntemp.indexOf('+');
    numonestore = stringassigntemp.slice(0,stringassigntemp.indexOf('+')); 
    numtwostore = "0";
    opstore = stringassigntemp.substr(indexofop,1); // can also use slice
// } // contemplate this bracket's positioning
    if (opstore = '+') {
        additionPerform(numonestore, numtwostore);
    } //|| if () || if () || if ()
}
}
else if (eqregexopandnumonly.test(inputhai.value) === true ) {
    stringassigntemp = inputhai.value;
    if (stringassigntemp.includes('+') === true) {
        indexofop = stringassigntemp.indexOf('+');
        numonestore = "0";
        numtwostore = stringassigntemp.slice(stringassigntemp.indexOf('+') + 1);
        opstore = stringassigntemp.substr(indexofop,1);
        if (opstore = '+') {
            additionPerform(numonestore, numtwostore);
        }
}
}
else if (eqregexoponly.test(inputhai.value) === true ) {
    stringassigntemp = inputhai.value;
    opOnlyEqualOp(); // /////// can also call additionPerform here. Take care to display string here. Akin to num only.
    // could/should also have been done directly.
}

// As of n-2 regex matches, not adding a condition for checking consecutive == yields no click upon clicking. Take note for the '+' operator.
}
// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx





deleteop.addEventListener("click", myFuncoDeleteOp);
function myFuncoDeleteOp() {
    stringassigntemp = inputhai.value;
    inputhai.value = stringassigntemp.slice(0, stringassigntemp.length - 1);
}

clearop.addEventListener("click", myFuncoClearOp);
function myFuncoClearOp() {
    // stringassigntemp = inputhai.value;
    inputhai.value = "";
}
// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx






function additionPerform (paramone, paramtwo) {
    let additionresult = Number(paramone) + Number(paramtwo);
    return inputhai.value = additionresult.toString(); // checking toString()
}
function subtractionPerform (paramuno, paramdos) {
    let subtractionresult = Number(paramuno) + Number(paramdos);
    return inputhai.value = subtractionresult.toString();
}
function multiplicationPerform (paramonee, paramtwoo) {
    let multiplicationresult = Number(paramonee) * Number(paramtwoo);
    return inputhai.value = multiplicationresult.toString();
}
function divisionPerform (paramunoo, paramdoss) {
    let divisionresult = Number(paramunoo) / Number(paramdoss);
    return inputhai.value = divisionresult.toString();
}

function numOnlyEqualOp (paraone) {
    // let displayprevdigit = Number(paraone);
    // return inputhai.value = displayprevdigit;
    return inputhai.value = paraone; //Number(paraone);  // upon getting NaN as an error, rectified it to assign a string value to the input field. The same solution is to be applied for opregexnumzeroatstart and opregexnumandoponly.
}
function numAndOpEqualOp (param1) {

}
function opOnlyEqualOp () {
    return inputhai.value = "0";
}
function noConsecutiveAddOp () {
    return inputhai.value += "+";
}




console.log(inputhai.value); // marker end check -----------------X------------------








</script>
</body>
</html>